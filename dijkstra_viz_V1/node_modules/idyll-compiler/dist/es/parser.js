var grammar = require('./grammar');
var ast = require('./ast');

var nearley = require('nearley');
var smartquotes = require('smartquotes');

var flattenChildren = function flattenChildren(nodeList) {
  return (nodeList || []).reduce(function (acc, child) {
    if (child[0] === '_idyllContainer') {
      acc = acc.concat(child[2]);
    } else {
      acc.push(child);
    }
    return acc;
  }, []);
};

var attrConvert = function attrConvert(list) {
  return (list || []).reduce(function (acc, _ref) {
    var name = _ref[0],
        _ref$ = _ref[1],
        type = _ref$[0],
        val = _ref$[1];

    if (type === 'value') {
      acc[name] = val;
    }
    return acc;
  }, {});
};

var makeFullWidth = function makeFullWidth(nodeList) {
  var currentTextContainer = [];
  var reduced = (nodeList || []).reduce(function (acc, child) {

    if (typeof child === 'string') {
      currentTextContainer.push(child);
      return acc;
    }
    var attrs = attrConvert(child[1] || []);
    var childName = child[0].toLowerCase();
    if (['derived', 'fullwidth', 'var'].indexOf(childName) > -1 || attrs.fullWidth) {
      if (childName === 'fullwidth') {
        child[0] = 'div';
        var className = ast.getProperty(child, 'className');
        if (className) {
          switch (className[0]) {
            case 'value':
              child = ast.setProperty(child, 'className', ['value', 'fullWidth ' + className[1]]);
              break;
            case 'expression':
              child = ast.setProperty(child, 'className', ['expression', '"fullWidth " + (' + className[1] + ')']);
              break;
            case 'variable':
              child = ast.setProperty(child, 'className', ['expression', '"fullWidth " + (' + className[1] + ')']);
              break;
            default:
              child = ast.setProperty(child, 'className', ['value', 'fullWidth']);
          }
        } else {
          child = ast.setProperty(child, 'className', ['value', 'fullWidth']);
        }
      } else {
        child = ast.removeProperty(child, 'fullWidth');
      }

      if (currentTextContainer.length) {
        acc = acc.concat([['TextContainer', [], currentTextContainer], child]);
      } else {
        acc = acc.concat([child]);
      }
      currentTextContainer = [];
    } else {
      currentTextContainer.push(child);
    }
    return acc;
  }, []);

  if (currentTextContainer.length) {
    return reduced.concat([['TextContainer', [], currentTextContainer]]);
  }
  return reduced;
};

var wrapText = function wrapText(nodeList) {
  return ast.modifyNodesByName(nodeList, 'TextContainer', function (node) {
    return ast.modifyChildren(node, function (child) {
      if (typeof child === 'string') {
        return ['p', [], [child]];
      }
      return child;
    });
  });
};

module.exports = function (input, tokens, positions, options) {
  options = options || {};

  /**
   * Clean results removes unnecessary
   * <p> tags inside of other blocks.
   */
  var cleanResults = function cleanResults(node) {
    if (typeof node === 'string') {
      if (options.smartquotes) {
        return smartquotes(node);
      }
      return node;
    }

    // flatten children
    node[2] = flattenChildren(node[2]);

    if (node[0] !== 'p' && node[2].length === 1 && typeof node[2][0] !== 'string' && node[2][0][0] === 'p' && node[2][0][2] && node[2][0][2].length === 1 && typeof node[2][0][2][0] === 'string') {
      return [node[0], node[1], node[2][0][2]];
    }

    // don't apply cleaning to codeblocks
    if (['pre', 'code', 'codehighlight'].indexOf(node[0].toLowerCase()) > -1) {
      return node;
    }
    return [node[0], node[1], node[2].map(cleanResults)];
  };

  var p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);
  try {
    p.feed(tokens);
  } catch (err) {
    var cleaned = tokens.substring(0, err.offset).replace(/"[^"]*"/g, 'x');
    var index = cleaned.match(/ /g).length;
    var position = positions[index];
    var message = 'Error parsing input at line ' + position[0] + ', column ' + position[1] + '\n\n' + input.split('\n')[position[0] - 1] + '\n' + Array(Math.max(0, position[1] - 2)).join(' ') + '^^^';
    var e = new Error(message);
    e.row = position[0];
    e.column = position[1];
    throw e;
  }
  var results = p.results;

  if (results.length) {
    // console.log('Results length: ' + results.length);
    if (results.length > 1) {}
    // console.log(JSON.stringify(results, null, 2));
    // console.log(str);

    // console.log(JSON.stringify(results[0]));

    return wrapText(makeFullWidth(flattenChildren(results[0])).map(cleanResults));
  }

  throw new Error('No parse results');
};